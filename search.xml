<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA时间格式为yyyy-MM-ddTHH:mm:ss.SSS+SSSS转为常用时间格式</title>
    <url>/2020/11/20/work-timestamp-to-time/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="JAVA时间格式为yyyy-MM-ddTHH-mm-ss-SSS-SSSS转为常用时间格式"><a href="#JAVA时间格式为yyyy-MM-ddTHH-mm-ss-SSS-SSSS转为常用时间格式" class="headerlink" title="JAVA时间格式为yyyy-MM-ddTHH:mm:ss.SSS+SSSS转为常用时间格式"></a>JAVA时间格式为yyyy-MM-ddTHH:mm:ss.SSS+SSSS转为常用时间格式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文记录了在JAVA开发工作中遇到了时间格式为：</p>
<p>yyyy-MM-ddTHH:mm:ss.SSS+SSSS</p>
<p>转为常用时间格式：</p>
<p>yyyy-MM-dd HH:mm:ss</p>
<p>的解决方法，提供给碰到和我一样的问题的小伙伴，如果有更好的解决方式，也希望能在评论告知！</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在开发中遇到返回值为</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"timestamp": "2020-11-19T03:12:08.121+0000"</span><br></pre></td></tr></table></figure>

<p>的时间数据，当时琢磨了很久还是没有找到合适的转换方式，也在墙内外进行过搜索，也依旧没有一个明了的解决方式，所以只能自己摸索了</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h4><ol>
<li>因为返回的时间是字符串类型（String），所以进行两次替换</li>
<li>将”+0000”替换为””非空格</li>
<li>将”T”替换为” “空格</li>
<li>SimpleDateFormat方法用格式为：yyyy-MM-dd HH:mm:ss.SSS 将原String转为Date</li>
<li>最后再用SimpleDateFormat方法转为自己想要的时间格式</li>
</ol>
<h4 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间格式转换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endTime yyyy-MM-ddTHH:mm:ss.SSS+SSSS</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">auxGetCommnetTime</span><span class="params">(String endTime)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先替换"T"，再替换"+0000"</span></span><br><span class="line">        endTime = endTime.replaceAll(<span class="string">"T"</span>,<span class="string">" "</span>).replaceAll(<span class="string">"\\+0000"</span>,<span class="string">""</span>);</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);</span><br><span class="line">        Date parse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parse = simpleDateFormat.parse(endTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要转化成的时间格式,时间格式自定义</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        <span class="keyword">return</span> sdf.format(parse);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>sprinboot使用freemarker导出word文档过程记录</title>
    <url>/2020/11/19/work-export-word-springboot/</url>
    <content><![CDATA[<h1 id="sprinboot使用freemarker导出word文档过程记录"><a href="#sprinboot使用freemarker导出word文档过程记录" class="headerlink" title="sprinboot使用freemarker导出word文档过程记录"></a>sprinboot使用freemarker导出word文档过程记录</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文为springboot使用freemarker技术导出word文档的过程记录。</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="1、代码部分"><a href="#1、代码部分" class="headerlink" title="1、代码部分"></a>1、代码部分</h3><h4 id="springboot项目创建"><a href="#springboot项目创建" class="headerlink" title="springboot项目创建"></a>springboot项目创建</h4><p><u>开发工具：idea</u></p>
<p><u>java版本：java8</u></p>
<p><u>springboot版本：2.1.6.RELEASE</u></p>
<p>创建一个maven项目，项目名称自定义，例如：ssqxx-word</p>
<p>创建完父类项目之后，删除生成的java文件夹和resources文件夹，新建一个子模块，模块命名自定义，例如：test-export-word-manage</p>
<a id="more"></a>

<h4 id="springboot导包"><a href="#springboot导包" class="headerlink" title="springboot导包"></a>springboot导包</h4><p>父类pom文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssqxx-word<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>导出word测试项目<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 模块 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>test-export-word-manage<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 属性定义和公共版本定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">springboot.version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">springboot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 管理jar包版本，Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement元素中指定的版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-dependencies --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springboot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>模块pom文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssqxx-word<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>test-export-word-manage<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- springboot web 包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- springboot freemarker 包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- framework 包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.avalon.framework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>avalon-framework-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="核心导出代码"><a href="#核心导出代码" class="headerlink" title="核心导出代码"></a>核心导出代码</h4><p>创建一个word导出工具类，导出word的所有步骤代码都放在这个类里</p>
<h5 id="WordUtil-java"><a href="#WordUtil-java" class="headerlink" title="WordUtil.java"></a>WordUtil.java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssqxx.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> freemarker.template.Configuration;</span><br><span class="line"><span class="keyword">import</span> freemarker.template.Template;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Encoder;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: WordUtil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: word导出工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ssqxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-11-19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Configuration configuration = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//classLoader.getResource()只能获取相对路径的资源</span></span><br><span class="line"><span class="comment">//     private static final String templateFolder = WordUtils.class.getClassLoader().getResource("template").getPath();</span></span><br><span class="line">    <span class="comment">//class.getResource()可以获取绝对路径和相对路径</span></span><br><span class="line">    private static final String templateFolder = com.ssqxx.util.WordUtil.class.getResource("/templates").getPath();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        configuration.setDefaultEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            configuration.setDirectoryForTemplateLoading(<span class="keyword">new</span> File(templateFolder));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WordUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出word文件到浏览器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> title 标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ftlFile 模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exportMillCertificateWord</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Map map, String title, String ftlFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Template freemarkerTemplate = configuration.getTemplate(ftlFile);</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        InputStream fin = <span class="keyword">null</span>;</span><br><span class="line">        ServletOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用工具类的createDoc方法生成Word文档</span></span><br><span class="line">            file = createDoc(map, freemarkerTemplate);</span><br><span class="line">            fin = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line">            response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">            response.setContentType(<span class="string">"application/msword"</span>);</span><br><span class="line">            <span class="comment">//获取指定格式时间</span></span><br><span class="line">            SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">            <span class="comment">// 设置浏览器以下载的方式处理该文件名</span></span><br><span class="line">            String fileName = title + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">".doc"</span>;</span><br><span class="line">            <span class="comment">//文件名称乱码解决</span></span><br><span class="line">            String encodedFileName = fileName +<span class="string">";filename*=utf-8''"</span>+URLEncoder.encode(fileName,<span class="string">"UTF-8"</span>);</span><br><span class="line">            response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span>+encodedFileName+<span class="string">""</span>);</span><br><span class="line">            response.setContentType(<span class="string">"application/vnd.ms-excel;charset=UTF-8"</span>);</span><br><span class="line">            response.setHeader(<span class="string">"Pragma"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line">            response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line">            response.setDateHeader(<span class="string">"Expires"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            out = response.getOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];  <span class="comment">// 缓冲区</span></span><br><span class="line">            <span class="keyword">int</span> bytesToRead = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 通过循环将读入的Word文件的内容输出到浏览器中</span></span><br><span class="line">            <span class="keyword">while</span> ((bytesToRead = fin.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, bytesToRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fin != <span class="keyword">null</span>) fin.close();</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="keyword">null</span>) out.close();</span><br><span class="line">            <span class="keyword">if</span> (file != <span class="keyword">null</span>) file.delete(); <span class="comment">// 删除临时文件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建的doc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataMap 数据内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> template 模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">createDoc</span><span class="params">(Map dataMap, Template template)</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"ssqxx.doc"</span>;</span><br><span class="line">        File f = <span class="keyword">new</span> File(name);</span><br><span class="line">        Template t = template;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这个地方不能使用FileWriter因为需要指定编码类型否则生成的Word文档会因为有无法识别的编码而无法打开</span></span><br><span class="line">            Writer w = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(f), <span class="string">"utf-8"</span>);</span><br><span class="line">            t.process(dataMap, w);</span><br><span class="line">            w.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本地文件图片获取base64码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getImageBase</span><span class="params">(String src)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (src == <span class="keyword">null</span> || src == <span class="string">""</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">         File file = <span class="keyword">new</span> File(src);</span><br><span class="line">         <span class="keyword">if</span> (!file.exists())</span><br><span class="line">             <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">         InputStream in = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">             data = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">             in.read(data);</span><br><span class="line">             in.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">        <span class="keyword">return</span> encoder.encode(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Base64码根据文件字节流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getImageBaseByInputStream</span><span class="params">(InputStream inputStream)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line">            inputStream.read(data);</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">        <span class="keyword">return</span> encoder.encode(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="业务导出代码"><a href="#业务导出代码" class="headerlink" title="业务导出代码"></a>业务导出代码</h4><h5 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssqxx.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ssqxx.service.ExportWordService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ExportWordController</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: word导出Controller类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ssqxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-11-19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"exportWord"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportWordController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ExportWordService exportWordService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出word方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"export"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportWord</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        exportWordService.exportWord(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h5><p>sevice类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssqxx.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ExportWordService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: word导出服务类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ssqxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-11-19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExportWordService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exportWord</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssqxx.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ssqxx.service.ExportWordService;</span><br><span class="line"><span class="keyword">import</span> com.ssqxx.util.WordUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ExportWordServiceImpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: word导出服务实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ssqxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-11-19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"exportWordService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportWordServiceImpl</span> <span class="keyword">implements</span> <span class="title">ExportWordService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportWord</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//添加测试数据</span></span><br><span class="line">        <span class="comment">//声明一个数据Map</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"name"</span>,<span class="string">"迈克尔"</span>);</span><br><span class="line">        map.put(<span class="string">"remark"</span>,<span class="string">"暂无"</span>);</span><br><span class="line">        <span class="comment">//测试列表数据</span></span><br><span class="line">        List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        list.add(<span class="string">"数据一"</span>);</span><br><span class="line">        list.add(<span class="string">"数据二"</span>);</span><br><span class="line">        list.add(<span class="string">"数据三"</span>);</span><br><span class="line">        map.put(<span class="string">"list"</span>,list);</span><br><span class="line">        <span class="comment">//测试map数据</span></span><br><span class="line">        Map mapT = <span class="keyword">new</span> HashMap();</span><br><span class="line">        mapT.put(<span class="string">"one"</span>,<span class="string">"mapOne"</span>);</span><br><span class="line">        mapT.put(<span class="string">"two"</span>,<span class="string">"mapTwo"</span>);</span><br><span class="line">        map.put(<span class="string">"mapT"</span>,mapT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加图片，地址为图片存放地址，需改成自己的文件地址</span></span><br><span class="line">        String imageOne = WordUtil.getImageBase(<span class="string">"C:/U***s/1****3/D*****p/微信图片_20200915162314.jpg"</span>);</span><br><span class="line">        map.put(<span class="string">"imageOne"</span>, imageOne);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将数据导出</span></span><br><span class="line">            WordUtil.exportMillCertificateWord(request,response,map,<span class="string">"导出word测试"</span>,<span class="string">"exportWord.ftl"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="模块配置文件"><a href="#模块配置文件" class="headerlink" title="模块配置文件"></a>模块配置文件</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7070</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">export-word-manage-service</span></span><br></pre></td></tr></table></figure>

<h3 id="2、模板部分"><a href="#2、模板部分" class="headerlink" title="2、模板部分"></a>2、模板部分</h3><h4 id="模板创建"><a href="#模板创建" class="headerlink" title="模板创建"></a>模板创建</h4><ul>
<li>使用WPS或者微软word进行模板编制</li>
<li>写好模板样式，最后在需要填充数据的地方写上标识，方便之后改成导出模板，例如：“占位”来作为标识</li>
<li>模板编制完成后，另存为，保存格式为xml格式！</li>
<li><em>建议插入图片占位时尽量使用较小的图片！</em></li>
</ul>
<p>例如：</p>
<p><img src="../../../../images/2020_11_19_01/001.jpg" alt=""></p>
<h4 id="模板修改"><a href="#模板修改" class="headerlink" title="模板修改"></a>模板修改</h4><p>项目的模块部分添加存放模板文件夹，在resources文件夹下新建templates文件夹</p>
<p>将生成好的xml模板，导入到项目模块中新建的templates文件夹里</p>
<p>修改xml模板的文件名，更改为：exportWord.ftl（名称可以自定义，在代码里对应上即可，不然会报错找不到文件！）</p>
<p>打开exportWord.ftl，进行格式的调整和修改（ftl用idea打开格式较乱的话，可以用Notepad++进行xml格式调整，这个操作不会的话，之后的文章会出！）</p>
<p>将模板中“占位”数据更改为传入map的key，例如：${name}</p>
<p><img src="../../../../images/2020_11_19_01/003.jpg" alt=""></p>
<p>模板中list的数据更改，需要加上&lt;#list 原名 as 作用名&gt;&lt;/#list&gt;</p>
<p><img src="../../../../images/2020_11_19_01/004.jpg" alt=""></p>
<p>模板中Map的数据更改，直接写map的值加上key，例如${map.key}</p>
<p><img src="../../../../images/2020_11_19_01/005.jpg" alt=""></p>
<p>模板中图片打印，先找到&lt;w:binData&gt;&lt;/w:binData&gt;，然后将中间的Base64位字符删除，更换为自己的数据名称，注意格式，不可以换行，否则图片打印不出来。例如${image}</p>
<p><img src="../../../../images/2020_11_19_01/007.jpg" alt=""></p>
<h3 id="3、导出效果"><a href="#3、导出效果" class="headerlink" title="3、导出效果"></a>3、导出效果</h3><p>完成以上步骤之后，就可以进行word导出测试了，我使用postman进行导出接口测试</p>
<p><img src="../../../../images/2020_11_19_01/008.jpg" alt=""></p>
<p>最终的效果为</p>
<p><img src="../../../../images/2020_11_19_01/009.jpg" alt=""></p>
<p>数据都已经打印出来了，图片也成功展示，word导出完成！</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>word导出的开发过程记录是在工作中项目需要用到word导出这个功能，然后去学习和寻找方法的，其实关键的地方在于<strong>模板的编制</strong>和<strong>导出核心代码</strong>。</p>
<p>这就是一个简单的springboot使用freemarker进行word文件导出的开发过程记录，希望能给你们的开发提供一些些帮助！</p>
<p>谢谢支持！</p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>export word</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础-List去重的6种方式</title>
    <url>/2020/11/18/java-base-six-way-to-list-remove-duplicate/</url>
    <content><![CDATA[<h1 id="JAVA基础-List去重的6种方式"><a href="#JAVA基础-List去重的6种方式" class="headerlink" title="JAVA基础-List去重的6种方式"></a>JAVA基础-List去重的6种方式</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>java开发中经常会遇到List去重这个工作，现在就来整理一下List去重的6种方式。</p>
<a id="more"></a>

<h2 id="方法代码以及效率测试"><a href="#方法代码以及效率测试" class="headerlink" title="方法代码以及效率测试"></a>方法代码以及效率测试</h2><h3 id="模拟测试数据"><a href="#模拟测试数据" class="headerlink" title="模拟测试数据"></a>模拟测试数据</h3><h4 id="相关代码："><a href="#相关代码：" class="headerlink" title="相关代码："></a>相关代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ListCleatMain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 模拟数据进行List去重测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ssqxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-11-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListCleatMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//声明一个新的List</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//数据装载开始时间</span></span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"数据装载开始时间:"</span> + startTime);</span><br><span class="line">        <span class="comment">//模拟添加200000个Integer</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">200000</span>;i++)&#123;</span><br><span class="line">            Integer in =(<span class="keyword">int</span>)(Math.random()*<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line">            list.add(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数据装载结束时间</span></span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"数据装载结束时间:"</span> + endTime);</span><br><span class="line">        <span class="comment">//数据装载时差</span></span><br><span class="line">        System.out.println(<span class="string">"数据装载时差："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原数据遍历打印</span></span><br><span class="line">        System.out.println(<span class="string">"原数据："</span>);</span><br><span class="line">        list.forEach( li-&gt; &#123;</span><br><span class="line">            System.out.print(li + <span class="string">"  "</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">long</span> startClear = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"开始时间:"</span> + startClear);</span><br><span class="line">        <span class="comment">//去重-双for循环去重</span></span><br><span class="line">        List newList = ListClearByDoubleFor.listRemove(list);</span><br><span class="line">        <span class="comment">//去重-Contains方法去重</span></span><br><span class="line"><span class="comment">//        List newList = ListClearByContains.listRemove(list);</span></span><br><span class="line">        <span class="comment">//去重-利用HashSet去重</span></span><br><span class="line"><span class="comment">//        List newList = ListClearByHashSet.listRemove(list);</span></span><br><span class="line">        <span class="comment">//去重-利用TreeSet去重</span></span><br><span class="line"><span class="comment">//        List newList = ListClearByTreeSet.listRemove(list);</span></span><br><span class="line">        <span class="comment">//去重-利用LinkedHashSet去重</span></span><br><span class="line"><span class="comment">//        List newList = ListClearByLinkedHashSet.listRemove(list);</span></span><br><span class="line">        <span class="comment">//去重-利用Java8的stream去重</span></span><br><span class="line"><span class="comment">//        List newList = ListClearByStream.listRemove(list);</span></span><br><span class="line">        <span class="comment">//结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endClear = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"结束时间："</span> + endClear);</span><br><span class="line">        <span class="comment">//时间差</span></span><br><span class="line">        System.out.println(<span class="string">"去重用时："</span> + (endClear - startClear));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//去重后数据遍历打印</span></span><br><span class="line">        System.out.println(<span class="string">"新数据："</span>);</span><br><span class="line">        newList.forEach(li -&gt; &#123;</span><br><span class="line">            System.out.print(li + <span class="string">"  "</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双for循环"><a href="#双for循环" class="headerlink" title="双for循环"></a>双for循环</h3><h4 id="实现思想："><a href="#实现思想：" class="headerlink" title="实现思想："></a>实现思想：</h4><p>使用两个for循环遍历集合所有元素，然后进行判断是否有相同元素，如果有，则去除。(有序)</p>
<h4 id="相关代码：-1"><a href="#相关代码：-1" class="headerlink" title="相关代码："></a>相关代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ListClearByDoubleFor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 双for循环进行list去重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ssqxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-11-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListClearByDoubleFor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据去重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">listRemove</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//双for循环进行list去重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;list.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (list.get(i).equals(list.get(j)))&#123;</span><br><span class="line">                    list.remove(j);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效率测试："><a href="#效率测试：" class="headerlink" title="效率测试："></a>效率测试：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据装载开始时间:1605667320390</span><br><span class="line">数据装载结束时间:1605667320407</span><br><span class="line">数据装载时差：17</span><br><span class="line">原数据：</span><br><span class="line">9  8  3  2  3  10  4  9  5  3  1  7  6  8  7  8  9  5  5  8  2  2 ……（20W数据）</span><br><span class="line">开始时间:1605667320811</span><br><span class="line">结束时间：1605667413269</span><br><span class="line">去重用时：92458（这还用再测？）</span><br><span class="line">新数据：</span><br><span class="line">9  8  3  2  10  4  5  1  7  6</span><br><span class="line">--------------------------------------------------</span><br><span class="line">&lt;!-- 200W(20以内)数据测试 --&gt;</span><br><span class="line">它不配！！！！！</span><br></pre></td></tr></table></figure>

<h3 id="List的contains方法"><a href="#List的contains方法" class="headerlink" title="List的contains方法"></a>List的contains方法</h3><h4 id="实现思想：-1"><a href="#实现思想：-1" class="headerlink" title="实现思想："></a>实现思想：</h4><p>利用List集合contains方法循环遍历，先创建新的List集合，接着循环遍历原来的List集合，判断新集合是否包含有旧集合，如果有，则不添加至新集合，否则添加。（有序） </p>
<h4 id="相关代码：-2"><a href="#相关代码：-2" class="headerlink" title="相关代码："></a>相关代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ListClearByContains</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 利用List集合contains方法循环遍历去重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ssqxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-11-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListClearByContains</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据去重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">listRemove</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//利用List集合contains方法循环遍历去重</span></span><br><span class="line">        List newList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.forEach(li -&gt; &#123;</span><br><span class="line">            <span class="comment">//判断新集合是否包含有，如果不包含有，则存入新集合中</span></span><br><span class="line">            <span class="keyword">if</span> (!newList.contains(li))&#123;</span><br><span class="line">                newList.add(li);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效率测试：-1"><a href="#效率测试：-1" class="headerlink" title="效率测试："></a>效率测试：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据装载开始时间:1605674583323</span><br><span class="line">数据装载结束时间:1605674583340</span><br><span class="line">数据装载时差：17</span><br><span class="line">原数据：</span><br><span class="line">8  10  7  3  7  6  6  1  7  6  2  8  9  6  6  5  2  6  5  5  3  1 ……（20W数据）</span><br><span class="line">开始时间:1605674583756</span><br><span class="line">结束时间：1605674583771</span><br><span class="line">去重用时：15&#x2F;13&#x2F;13&#x2F;13&#x2F;11（5次测试）</span><br><span class="line">新数据：</span><br><span class="line">8  10  7  3  6  1  2  9  5  4</span><br><span class="line">--------------------------------------------------</span><br><span class="line">&lt;!-- 200W(20以内)数据测试 --&gt;</span><br><span class="line">开始时间:1605680194498</span><br><span class="line">结束时间：1605680194553</span><br><span class="line">去重用时：55&#x2F;57&#x2F;56&#x2F;61&#x2F;64（打印原数据）</span><br><span class="line">去重用时：144&#x2F;120&#x2F;127&#x2F;124&#x2F;125（不打印原数据）</span><br><span class="line">新数据：</span><br><span class="line">17  3  2  16  13  6  18  1  10  5  11  7  20  9  15  14  12  8  19  4</span><br></pre></td></tr></table></figure>

<h3 id="HashSet方法"><a href="#HashSet方法" class="headerlink" title="HashSet方法"></a>HashSet方法</h3><h4 id="实现思想：-2"><a href="#实现思想：-2" class="headerlink" title="实现思想："></a>实现思想：</h4><p>HashSet实现了Set接口，不允许出现重复元素。可以基于这个想法，把List集合所有元素存入HashSet对象，接着把List集合元素全部清空，最后把HashSet对象元素全部添加至List集合中，这样就可以保证不出现重复元素。而HashSet有一个构造函数，在初始化时可以直接添加元素。其中，HashSet不能保证顺序不变，所以此方式不能保证List集合原来的顺序不变。 （无序）</p>
<h4 id="相关代码：-3"><a href="#相关代码：-3" class="headerlink" title="相关代码："></a>相关代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ListClearByHashSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: List集合放入HashSet中利用HashSet实现Set接口的无重复元素特性去重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ssqxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-11-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListClearByHashSet</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据去重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">listRemove</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//List集合放入HashSet中利用HashSet实现Set接口的无重复元素特性去重</span></span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet(list);</span><br><span class="line">        list.clear();</span><br><span class="line">        list.add(set);</span><br><span class="line"><span class="comment">//        Iterator it = set.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())&#123;</span></span><br><span class="line"><span class="comment">//            list.add(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效率测试：-2"><a href="#效率测试：-2" class="headerlink" title="效率测试："></a>效率测试：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据装载开始时间:1605675392758</span><br><span class="line">数据装载结束时间:1605675392776</span><br><span class="line">数据装载时差：18</span><br><span class="line">原数据：</span><br><span class="line">3  6  1  1  7  6  9  2  8  6  4  7  1  9  5  5  4  3  3  1  10  8  10  10……（20w数据）</span><br><span class="line">开始时间:1605675393184</span><br><span class="line">结束时间：1605675393200</span><br><span class="line">去重用时：16&#x2F;20&#x2F;15&#x2F;12&#x2F;15（5次测试）</span><br><span class="line">新数据：</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">--------------------------------------------------</span><br><span class="line">&lt;!-- 200W(20以内)数据测试 --&gt;</span><br><span class="line">开始时间:1605680088596</span><br><span class="line">结束时间：1605680088641</span><br><span class="line">去重用时：45&#x2F;45&#x2F;46&#x2F;52&#x2F;44（打印原数据）</span><br><span class="line">去重用时：167&#x2F;163&#x2F;160&#x2F;164&#x2F;166（不打印原数据）</span><br><span class="line">新数据：</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]</span><br></pre></td></tr></table></figure>

<h3 id="TreeSet方法"><a href="#TreeSet方法" class="headerlink" title="TreeSet方法"></a>TreeSet方法</h3><h4 id="实现思想：-3"><a href="#实现思想：-3" class="headerlink" title="实现思想："></a>实现思想：</h4><p> TreeSet集合也是实现Set接口，是一个有序的，并且无重复元素集合。（有序）</p>
<h4 id="相关代码：-4"><a href="#相关代码：-4" class="headerlink" title="相关代码："></a>相关代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ListClearByTreeSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: List集合放入TreeSet中利用HashSet实现Set接口的无重复元素特性去重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ssqxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-11-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListClearByTreeSet</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据去重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">listRemove</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//List集合放入TreeSet中利用HashSet实现Set接口的无重复元素特性去重</span></span><br><span class="line">        TreeSet set = <span class="keyword">new</span> TreeSet(list);</span><br><span class="line">        list.clear();</span><br><span class="line">        list.add(set);</span><br><span class="line"><span class="comment">//        Iterator it = set.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())&#123;</span></span><br><span class="line"><span class="comment">//            list.add(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效率测试：-3"><a href="#效率测试：-3" class="headerlink" title="效率测试："></a>效率测试：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据装载开始时间:1605675683470</span><br><span class="line">数据装载结束时间:1605675683487</span><br><span class="line">数据装载时差：17</span><br><span class="line">原数据：</span><br><span class="line">8  10  4  3  8  10  8  2  1  9  1  3  1  1  8  3  4  4  10  6  6  2……（20W数据）</span><br><span class="line">开始时间:1605675683881</span><br><span class="line">结束时间：1605675683909</span><br><span class="line">去重用时：28&#x2F;25&#x2F;29&#x2F;26&#x2F;26（5次测试）</span><br><span class="line">新数据：</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">--------------------------------------------------</span><br><span class="line">&lt;!-- 200W(20以内)数据测试 --&gt;</span><br><span class="line">开始时间:1605679953606</span><br><span class="line">结束时间：1605679953697</span><br><span class="line">去重用时：91&#x2F;94&#x2F;104&#x2F;103&#x2F;101（打印原数据）</span><br><span class="line">去重用时：112&#x2F;119&#x2F;123&#x2F;113&#x2F;117（不打印原数据）</span><br><span class="line">新数据：</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashSet方法"><a href="#LinkedHashSet方法" class="headerlink" title="LinkedHashSet方法"></a>LinkedHashSet方法</h3><h4 id="实现思想：-4"><a href="#实现思想：-4" class="headerlink" title="实现思想："></a>实现思想：</h4><p>LinkedHashSet是一个实现Set接口将ArrayList删除重复数据的最佳方法。LinkedHashSet在内部完成两件事：删除重复数据，保持添加到其中的数据的顺序。（有序）</p>
<h4 id="相关代码：-5"><a href="#相关代码：-5" class="headerlink" title="相关代码："></a>相关代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ListClearByLinkedHashSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: List集合放入LinkedHashSet中利用LinkedHashSet实现Set接口的无重复元素特性去重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ssqxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-11-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListClearByLinkedHashSet</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据去重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">listRemove</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//List集合放入LinkedHashSet中利用LinkedHashSet实现Set接口的无重复元素特性去重</span></span><br><span class="line">        LinkedHashSet hashSet = <span class="keyword">new</span> LinkedHashSet(list);</span><br><span class="line">        list.clear();</span><br><span class="line">        list.add(hashSet);</span><br><span class="line"><span class="comment">//        Iterator iterator = hashSet.iterator();</span></span><br><span class="line"><span class="comment">//        while(iterator.hasNext())&#123;</span></span><br><span class="line"><span class="comment">//            list.add(iterator.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效率测试：-4"><a href="#效率测试：-4" class="headerlink" title="效率测试："></a>效率测试：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据装载开始时间:1605675839400</span><br><span class="line">数据装载结束时间:1605675839417</span><br><span class="line">数据装载时差：17</span><br><span class="line">原数据：</span><br><span class="line">2  7  5  1  4  4  1  5  1  9  10  7  3  9  7  3  6  7  1  1  4……（20W数据）</span><br><span class="line">开始时间:1605675839818</span><br><span class="line">结束时间：1605675839835</span><br><span class="line">去重用时：17&#x2F;16&#x2F;14&#x2F;17&#x2F;19（5次测试）</span><br><span class="line">新数据：</span><br><span class="line">[2, 7, 5, 1, 4, 9, 10, 3, 6, 8]</span><br><span class="line">--------------------------------------------------</span><br><span class="line">&lt;!-- 200W(20以内)数据测试 --&gt;</span><br><span class="line">开始时间:1605679823889</span><br><span class="line">结束时间：1605679823938</span><br><span class="line">去重用时：49&#x2F;43&#x2F;42&#x2F;42&#x2F;44（打印原数据）</span><br><span class="line">去重用时：173&#x2F;159&#x2F;160&#x2F;163&#x2F;169（不打印原数据）</span><br><span class="line">新数据：</span><br><span class="line">[12, 1, 9, 6, 3, 8, 19, 13, 5, 16, 2, 10, 11, 15, 17, 4, 7, 20, 14, 18]</span><br></pre></td></tr></table></figure>

<h3 id="Java8的stream方法"><a href="#Java8的stream方法" class="headerlink" title="Java8的stream方法"></a>Java8的stream方法</h3><h4 id="实现思想：-5"><a href="#实现思想：-5" class="headerlink" title="实现思想："></a>实现思想：</h4><p>要从arraylist中删除重复项，我们也可以使用java 8 stream api。使用steam的distinct()方法返回一个由不同数据组成的流，通过对象的equals（）方法进行比较。 （有序）</p>
<h4 id="相关代码：-6"><a href="#相关代码：-6" class="headerlink" title="相关代码："></a>相关代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ListClearByStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 使用java8新特性stream实现List去重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ssqxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-11-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListClearByStream</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据去重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">listRemove</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用java8新特性stream实现List去重</span></span><br><span class="line">        List newList = (List) list.stream().distinct().collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效率测试：-5"><a href="#效率测试：-5" class="headerlink" title="效率测试："></a>效率测试：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据装载开始时间:1605679132825</span><br><span class="line">数据装载结束时间:1605679132841</span><br><span class="line">数据装载时差：16</span><br><span class="line">原数据：</span><br><span class="line">7  3  4  6  5  2  7  8  5  6  7  4  3  8  6  5  2  4  5  5  2  10  2……（20W数据）</span><br><span class="line">开始时间:1605679133233</span><br><span class="line">结束时间：1605679133248</span><br><span class="line">去重用时：15&#x2F;14&#x2F;13&#x2F;19&#x2F;16（5次测试）</span><br><span class="line">新数据：</span><br><span class="line">7  3  4  6  5  2  8  10  9  1</span><br><span class="line">--------------------------------------------------</span><br><span class="line">&lt;!-- 200W(20以内)数据测试 --&gt;</span><br><span class="line">开始时间:1605679582415</span><br><span class="line">结束时间：1605679582443</span><br><span class="line">去重用时：28&#x2F;31&#x2F;35&#x2F;27&#x2F;31（打印原数据）</span><br><span class="line">去重用时：94&#x2F;81&#x2F;96&#x2F;96&#x2F;87（不打印原数据）</span><br><span class="line">新数据：</span><br><span class="line">8  15  4  3  17  1  10  19  12  9  16  20  7  6  18  13  2  5  14  11</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h3 id="随机数在200000范围10以内（平均值）："><a href="#随机数在200000范围10以内（平均值）：" class="headerlink" title="随机数在200000范围10以内（平均值）："></a>随机数在200000范围10以内（平均值）：</h3><ul>
<li>使用两个for循环实现List去重：94258毫秒</li>
<li>使用List集合contains方法循环遍历去重时间：13毫秒 </li>
<li>使用HashSet实现List去重时间：16毫秒</li>
<li>使用TreeSet实现List去重时间：27毫秒</li>
<li>使用LinkedHashSet实现List去重时间：17毫秒</li>
<li>使用java8新特性stream实现List去重：15毫秒</li>
</ul>
<h3 id="随机数在2000000范围20以内（平均值）："><a href="#随机数在2000000范围20以内（平均值）：" class="headerlink" title="随机数在2000000范围20以内（平均值）："></a>随机数在2000000范围20以内（平均值）：</h3><ul>
<li>使用两个for循环实现List去重：已放弃！！！！</li>
<li>使用List集合contains方法循环遍历去重时间：128毫秒 </li>
<li>使用HashSet实现List去重时间：164毫秒</li>
<li>使用TreeSet实现List去重时间：117毫秒</li>
<li>使用LinkedHashSet实现List去重时间：165毫秒</li>
<li>使用java8新特性stream实现List去重：91毫秒</li>
</ul>
<h3 id="随机数在20000000范围20以内（一次值）："><a href="#随机数在20000000范围20以内（一次值）：" class="headerlink" title="随机数在20000000范围20以内（一次值）："></a>随机数在20000000范围20以内（一次值）：</h3><ul>
<li>使用两个for循环实现List去重：已放弃！！！！</li>
<li>使用List集合contains方法循环遍历去重时间：612毫秒 </li>
<li>使用HashSet实现List去重时间：334毫秒</li>
<li>使用TreeSet实现List去重时间：813毫秒</li>
<li>使用LinkedHashSet实现List去重时间：364毫秒</li>
<li>使用java8新特性stream实现List去重：214毫秒</li>
</ul>
<h3 id="结论简述："><a href="#结论简述：" class="headerlink" title="结论简述："></a>结论简述：</h3><p>目前表现最好的是java8新特性stream实现的list去除，不论是数据量大小；</p>
<p>HashSet、TreeSet、LinkedHashSet都有实现Set接口，所以速度都不会很慢，但是在过了1000W这个数量的list后去重速度骤降，HashSet，LinkedHashSet依旧稳定快速；整体上HashSet&gt;LinkedHashSet&gt;TreeSet。不过HashSet是无序的，若想有序可以使用LinkedHashSet；</p>
<p>list集合的contains方法在数据量不大的时候能去重速度也挺快的，甚至能超过HashSet，但数据量大（500W）之后，去重速度骤降，数据量不大的list去重可以使用；</p>
<p>双for循环进行list去重就……算了，放弃吧！</p>
<h3 id="整体排序："><a href="#整体排序：" class="headerlink" title="整体排序："></a>整体排序：</h3><h4 id="500W数据以下："><a href="#500W数据以下：" class="headerlink" title="500W数据以下："></a>500W数据以下：</h4><ul>
<li>（有序）stream&gt;contains&gt;LinkedHashSet&gt;TreeSet&gt;for</li>
<li>（无序）stream&gt;contains&gt;HashSet&gt;LinkedHashSet&gt;TreeSet&gt;for</li>
</ul>
<h4 id="500W数据以上："><a href="#500W数据以上：" class="headerlink" title="500W数据以上："></a>500W数据以上：</h4><ul>
<li>（有序）stream&gt;LinkedHashSet&gt;contains&gt;TreeSet&gt;for</li>
<li>（无序）stream&gt;HashSet&gt;LinkedHashSet&gt;contains&gt;TreeSet&gt;for</li>
</ul>
<p><em>以上数据为自测数据，可能与实际应用会存在误差，下次再测试一下String（字符串）的list排序。</em></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>http/tcp协议基础</title>
    <url>/2020/04/14/http-tcp-ip-base/</url>
    <content><![CDATA[<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p><img src="../../../../images/2020_04_14_01/network_model.jpg" alt="network_model"></p>
<p>各层的关系</p>
<p>每一个抽象层建立在低一层提供的服务上，并且为高一层提供服务。</p>
<a id="more"></a>

<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p><img src="../../../../images/2020_04_14_01/http_structure_chart.jpg" alt="http_structure_chart"></p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>HTTP协议是一个无状态的，应用层级的超文本传输协议（Hyper Text Transfer Protocol）</strong></p>
<ul>
<li>HTTP是用于从WWW服务器传输超文本到本地浏览器的传送协议；不仅保证计算机正确快速的传输超文本文档，还确定传输文档中的内容，以及确定内容的优先显示等。</li>
<li>HTTP是一个应用层协议，有请求和相应构成，是一个标准的客户端服务模型。</li>
<li>HTTP是一个无状态的协议，同一个客户端的这次请求和上次请求时没有对应关系的。</li>
<li>默认HTTP的端口为80；HTTPS的默认端口为443。</li>
<li>HTTP协议永远时客户端发起请求，服务端回送响应。</li>
</ul>
<h4 id="HTTP事务工作过程"><a href="#HTTP事务工作过程" class="headerlink" title="HTTP事务工作过程"></a>HTTP事务工作过程</h4><p>工作过程有以下四步：</p>
<ol>
<li>首先客户端与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。</li>
<li>建立连接后，客户端发送一个请求给服务器。请求方式的格式为：<u>统一资源标识符（URI）、协议版本号、MIME信息（包括请求修饰符、客户端信息和可能的内容）</u></li>
<li>服务器接到请求后，给予相应的响应信息。</li>
<li>客户端接收到服务器所返回的信息，通过浏览器显示在用户的显示屏上，然后客户端与服务器断开连接。</li>
</ol>
<h4 id="HTTP的优点"><a href="#HTTP的优点" class="headerlink" title="HTTP的优点"></a>HTTP的优点</h4><ul>
<li>简单快捷。HTTP协议简单，通信速度快。</li>
<li>灵活。HTTP协议允许传输任意类型的数据</li>
<li>短链接。HTTP协议限制每次连接只处理一个请求，服务器对客户端的请求作出响应后，马上断开连接。这种传输方式可以节省传输时间。</li>
</ul>
<h4 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h4><p><strong>常用的请求方式：GET/POST</strong></p>
<ol>
<li>GET方式： 是以实体的方式得到由请求URI所指定资源的信息。</li>
<li>POST方式： 用来向目的服务器发出请求，要求它接受被附在请求后的实体。</li>
</ol>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>HTTPS：是HTTP的安全版。HTTP下加入SSL层，HTTPS的安全基础就是SSL。</p>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p><strong>状态码分为客户端错误状态码、服务端错误状态码、成功状态码、重定向状态码等。</strong></p>
<ul>
<li>1**类状态码：Information状态码，表示信息正在处理。</li>
<li>2**类状态码：Success状态码，表示请求正常完成。</li>
<li>3**类状态码：Redirection状态码，表示需要客户端进行附加操作（如跳转、重定向）。</li>
<li>4**类状态码：Error状态码，通常是由于客户端的错误导致的。</li>
<li>5**类状态码：SeverError状态码，通常是服务端的错误导致的。</li>
</ul>
<h2 id="TCP-IP系列协议"><a href="#TCP-IP系列协议" class="headerlink" title="TCP/IP系列协议"></a>TCP/IP系列协议</h2><p>TCP/IP是internet最基本的协议，把所有TCP/IP系列协议归类到四个抽象层中。</p>
<h4 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h4><p><img src="../../../../images/2020_04_14_01/transmit.png" alt="transmit"></p>
<ul>
<li>TCP 面向连接的、可靠的流协议；</li>
<li>UDP  面向无连接的通讯协议；</li>
<li>IP    在源地址和目的地址之间传送的数据包；</li>
<li>ICMP 控制报文协议；</li>
<li>IGMP internet组管理协议；</li>
<li>ARP 地址解析协议；</li>
<li>RARP 反向地址转化协议</li>
</ul>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul>
<li>建立一个TCP连接需要经过“三次握手”。TCP三次握手具体过程如下：</li>
</ul>
<ol>
<li>第一次握手：客户端发送syn包（syn=j）到服务器，并进入SYN_SEND状态。等待服务器确认。</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。</li>
<li>第三次握手：客户端接收到服务器的SYN_ACK包，向服务器发送确认包ACK（ack=k+1），包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>
</ol>
<ul>
<li><strong>握手过程中，传送的包里不包含数据，三次握手完毕后，客户端与服务器正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”。</strong></li>
<li><strong>SYN（synchronous）是TCP建立连接时使用的握手信号；ACK（acknowledge）即确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符，表示发来的数据已确认接收无误。</strong></li>
<li><u>如果两次握手会怎么样呢？</u></li>
</ul>
<h5 id="理解题意：就是客户端为什么还要发送一次确认呢？"><a href="#理解题意：就是客户端为什么还要发送一次确认呢？" class="headerlink" title="理解题意：就是客户端为什么还要发送一次确认呢？"></a>理解题意：就是客户端为什么还要发送一次确认呢？</h5><p>答：为了防止已经失效的连接请求报文又突然传送到了服务器，而产生错误。假设一种异常，客户端发出的请求由于网络阻塞没有及时到达服务器，后又重传请求，之后服务器相应了，切建立了连接，之后连接又释放了。此时假设客户端发出的第一个请求到达服务器，服务器误以为是客户端再次请求连接，服务器建立连接，如果采用两次握手，此时连接建立，而客户端又不发送数据，浪费了服务器的资源。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul>
<li>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。</li>
</ul>
<ol>
<li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发送数据了。</li>
<li>第二次挥手：被动关闭方接收到FIN包后，发送一个ACK给对方，确认序号为收到序列+1。</li>
<li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li>
<li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序列为收到序列号+1。至此，完成四次握手。</li>
</ol>
<h4 id="握手与挥手图示"><a href="#握手与挥手图示" class="headerlink" title="握手与挥手图示"></a>握手与挥手图示</h4><p><img src="../../../../images/2020_04_14_01/handshake_with_wave.jpeg" alt="handshake_with_wave"></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="../../../../images/2020_04_14_01/theory.png" alt="theory"></p>
<ol>
<li><p>Socket套接字：TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）。</p>
</li>
<li><p>TCP缓冲区：每个TCP的Socket的内核中都有一个发送缓冲区和一个接受缓冲区。</p>
</li>
<li><p>阻塞模式</p>
<p>A.接收端缓冲区为空，接收端调用read方法的线程阻塞。</p>
<p>B.发送端缓存区满了或者不够大，发送端调用write方法的线程阻塞。</p>
</li>
<li><p>TCP的可靠性与高效率——滑动窗口</p>
<p>A.滑动窗口：发送方和接收方都会维护一个数据帧的序列，这个序列称作为窗口。</p>
<p>B.发送方的窗口大小由接收方确认</p>
<p>C.目的</p>
<ol>
<li>确保数据不丢失：如果发送的数据丢失了可重新发</li>
<li>控制发送速度：控制发送速度，以免接收方的缓存区不够大导致溢出，同时控制流量也可以避免网络拥塞。</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="../../../../images/2020_04_14_01/network_model_summary.jpg" alt="network_model_summary"></p>
<h4 id="TCP-IP与HTTP的区别"><a href="#TCP-IP与HTTP的区别" class="headerlink" title="TCP/IP与HTTP的区别"></a>TCP/IP与HTTP的区别</h4><ol>
<li>TCP/IP协议（Transmission Control Protocol/Internet Protocol）：是传输层协议。主要解决数据如何在网络中传输。</li>
<li>HTTP：是请求响应模式，是应用层协议。主要解决如何包装数据。</li>
<li>Web使用HTTP协议作为应用层协议，以封装http文本信息，然后使用TCP/IP做传输层协议将它发送到网络上。HTTP是利用TCP在两台电脑（通常是web服务器和客户端）之间传输信息的协议。</li>
<li>HTTP协议是建立在TCP协议基础之上的。当浏览器需要从服务器获取网页数据时，会发出一次HTTP请求。HTTP会通过TCP建立一个到服务器的连接通道，当本次请求需要的数据完毕后，HTTP会立即将TCP连接断开。</li>
<li>HTTP连接最显著的特点是：客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程为“一次连接”。</li>
<li>TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，是简单的传输。HTTP是用来收发数据的。</li>
<li>TCP/IP协议是一个协议集合。TCP/IP协议按照层次分为以下四层：应用层、传输层、网络层、数据链路层。分层的目的是：一个层只负责一个层次的问题，只要维护好这个层次就可以了。</li>
</ol>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>初次上手UbuntuOS</title>
    <url>/2019/11/20/first-use-UbuntuOS/</url>
    <content><![CDATA[<h4 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h4><p>之前学习和使用的 linux 系统都是 centOS，在学习 docker 的时候，请教公司的大神，从大神口中得到一个总结：centOS 更适用于运维，UbuntuOS 更适用开发！</p>
<p>所以这次想体验一下 UbuntuOS，看看有什么不同之处！</p>
<a id="more"></a>

<p>好啦！先去官网搞一个<a href="https://ubuntu.com/" target="_blank" rel="noopener">UbuntuOS</a>的<a href="https://ubuntu.com/download/desktop" target="_blank" rel="noopener">镜像 IOS</a>。</p>
<p>直接下载 ubuntu18.04 版本（最新版）在虚拟机进行镜像安装。我选用的虚拟机是 Oracle VM virtualBox!</p>
<p>完成一系列的镜像安装操作后，启动我的 UnubtuOS！</p>
<p><img src="../../../../images/2019_11_20_01/ubuntu1.1.png" alt="ubuntu1.1"></p>
<p>安装初始化就是慢！！！</p>
<p>安装成功，发现登录进来不是最高权限！！！！！！Oh No！！！！</p>
<p><img src="../../../../images/2019_11_20_01/HoNo.gif" alt="HoNo"></p>
<p>好吧！为了安全，第一次登录都是让用户先建一个用户……</p>
<p>那怎么办，我只好 su root 了………………</p>
<p>password：………………</p>
<p>我哪知道密码呀！！！！</p>
<p>原来 UbuntuOS 的 root 密码每次登录进来都会自动刷新，不是固定的，，裂了……</p>
<p>没办法，只能百度了。。。。：怎么修改 Ubuntu 的密码</p>
<p><img src="../../../../images/2019_11_20_01/onlyOneTure.gif" alt="onlyOneTure"></p>
<p>点开<a href="https://www.fujieace.com/linux/sudo-passwd.html" target="_blank" rel="noopener">第一个</a>！！！！</p>
<p>既然默认 root 密码是随机的，即每次开机都有一个新的 root 密码。我们只需要修改默认的 root 密码就行！</p>
<p>我们先在终端输入命令 sudo passwd，然后再输入 root 用户的密码。</p>
<p>成功修改完密码，进入 root！哈哈哈哈！！！……</p>
<p>等一下，我为啥要进入 root，，，，原因是我**Xshell 连接不成功。。。</p>
<p>同样百度打开：ubuntu 无法连接 xshell</p>
<p>原来是 Ubuntu 主机没有开启 ssh 服务，需要开启 openssh-server</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># sudo apt-get install openssh-server</span></span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># ps -e | grep ssh</span></span><br></pre></td></tr></table></figure>

<p>如果只有 ssh-agent 表示还没启动，需要</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># /etc/init.d/ssh start</span></span><br></pre></td></tr></table></figure>

<p>如果显示 sshd 则说明已启动成功。</p>
<p>太棒了！感觉学到了许多！。。。。。</p>
<p>嘿嘿！</p>
<hr>
<h4 id="鸣谢："><a href="#鸣谢：" class="headerlink" title="鸣谢："></a>鸣谢：</h4><p><a href="https://www.fujieace.com/linux/sudo-passwd.html" target="_blank" rel="noopener">付杰博客</a></p>
<p><a href="https://www.cnblogs.com/yadongliang/p/8663146.html" target="_blank" rel="noopener">习惯沉淀-个人博客</a></p>
<h4 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h4><p>Ubuntu 有一个非常方便的创建文本的命令</p>
<p>tee 文件 &lt;&lt;-’EOF’</p>
<p>//要粘贴进来的文本信息</p>
<p>EOF</p>
<p>完成文本信息文件创建，简化了创建到编辑再保存的步骤</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>UbuntuOS</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud 学习笔记三： 服务的注册与发现</title>
    <url>/2019/10/25/the-learning-notes-by-SpringCloud-Eureka/</url>
    <content><![CDATA[<h2 id="SpringCloud-微服务构建一：服务的注册与发现-Eureka"><a href="#SpringCloud-微服务构建一：服务的注册与发现-Eureka" class="headerlink" title="SpringCloud 微服务构建一：服务的注册与发现-Eureka"></a>SpringCloud 微服务构建一：服务的注册与发现-Eureka</h2><h3 id="一：服务发现"><a href="#一：服务发现" class="headerlink" title="一：服务发现"></a>一：服务发现</h3><p>在微服务架构中，服务发现组件是很关键的一个组件，服务发现组件就是去管理各服务的网络地址等信息。</p>
<p>服务提供者、服务消费者、服务发现组件的关系：</p>
<ol>
<li>服务启动时，会将自己的网络地址等信息注册到服务发现组件中，让服务发现组件去存储管理这些信息。</li>
<li>服务消费者从服务发现组件这里查询服务提供者的网路地址信息，并使用该地址去调用服务提供者的接口。</li>
<li>各服务和服务发现组件通过一定的机制通信（心跳）。</li>
</ol>
<p>Spring Cloud 支持多种服务发现组件，如 Eureka、Consul 和 Zookeeper 等，这里主要介绍 Spring Cloud Eureka 的使用。</p>
<a id="more"></a>

<h3 id="二：Eureka-介绍"><a href="#二：Eureka-介绍" class="headerlink" title="二：Eureka 介绍"></a>二：Eureka 介绍</h3><p>Eureka 是 Netflix 开源的服务治理模块，本身是一个基于 Rest 的服务。</p>
<ul>
<li>基于 Netflix Eureka 做了二次封装</li>
<li>两个组件组成：<ul>
<li>Eureka Server 注册中心<ul>
<li>Eureka Server 提供服务发现的功能，服务启动后，向 Eureka Server 注册自己的地址信息（IP、端口、服务名）</li>
<li>当 Eureka Server 在一定时间内接收不到某个服务实例的心跳，将会注销该实例，默认时间为 90 秒</li>
<li>默认情况下 Eureka Server 同时也是 Eureka Client。多个 Eureka Server 实例通过复制的方式来实现服务注册</li>
</ul>
</li>
<li>Eureka Client 服务中心<ul>
<li>Eureka Client 是一个客户端，用于与 Eureka 的交互 0 服务启动后，与 Eureka Server 通过 心跳 机制通信，默认周期为 30 秒</li>
<li>Eureka Client 有 缓存机制，会缓存服务注册表中的信息。服务不需要每次请求都查询 Eureka Server，这样既降低了 Server 的压力，同时即便 Eureka Server 的节点都宕机了，也可以使用缓存查询到服务提供者的信息完成调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Eureka 架构图：</p>
<p><img src="../../../../images/2019_10_25_01/SpringCloud-Eureka-framework-1584847429893.jpg" alt="SpringCloud-Eureka-framework"></p>
<h4 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h4><h5 id="eureka-server-–注册中心服务端"><a href="#eureka-server-–注册中心服务端" class="headerlink" title="eureka server –注册中心服务端"></a>eureka server –注册中心服务端</h5><p>创建一个 maven 项目，之后在 pom 文件添加 Eureka Server 的依赖，pom.xml 主要内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.9.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">    &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;eureka&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;eureka&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">        	&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">        	&lt;spring-cloud.version&gt;Greenwich.SR3&lt;/spring-cloud.version&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">        	&lt;dependency&gt;</span><br><span class="line">        		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        		&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">        	&lt;/dependency&gt;</span><br><span class="line">        	&lt;dependency&gt;</span><br><span class="line">        		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        	&lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">        &lt;dependencyManagement&gt;</span><br><span class="line">        	&lt;dependencies&gt;</span><br><span class="line">        	&lt;dependency&gt;</span><br><span class="line">        		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        		&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">        		&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">        		&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        		&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        	&lt;/dependency&gt;</span><br><span class="line">        	&lt;/dependencies&gt;</span><br><span class="line">        &lt;/dependencyManagement&gt;</span><br><span class="line">        &lt;build&gt;</span><br><span class="line">        	&lt;plugins&gt;</span><br><span class="line">        		&lt;plugin&gt;</span><br><span class="line">        			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        			&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        		&lt;/plugin&gt;</span><br><span class="line">        	&lt;/plugins&gt;</span><br><span class="line">        &lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>创建一个启动类：EurekaApplication</p>
<p>启动前在 EurekaApplication 启动类加上 Eureka 服务的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaServer</span> <span class="comment">//声明这是一个Eureka的服务类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>启动之后可以打开 127.0.0.1:8080（默认为 8080）</p>
<p>进入注册中心，则 Eureka Server 算初步完成创建</p>
<p>启动之后你会发现控制台在报错：</p>
<p><img src="../../../../images/2019_10_25_01/SpringCloud-error-not-find-server-1584847543347.jpg" alt="SpringCloud-error-not-find-server"></p>
<p>因为 Server 也是 Client，所以自己也需要注册进服务里面，有两种方式解决：</p>
<ol>
<li>将自己注册进自己的服务里</li>
<li>配置自己不注册到服务中</li>
</ol>
<p>二选一就能够解决控制台的报错！</p>
<p>配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">eureka-server1</span> <span class="comment">#服务名称</span></span><br><span class="line">            <span class="attr">server:</span></span><br><span class="line">            	<span class="attr">port:</span> <span class="number">8761</span> <span class="comment">#配置启动port，可以用localhost:8761启动了#1.将自己注册进自己的服务里</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">service-url:</span></span><br><span class="line">			<span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:8761/eureka/</span> <span class="string">、</span></span><br><span class="line"><span class="comment">#defaultZone 是与 Eureka Server 交互地址，用于查询服务和注册服务 （默认端口是 8761），如果要向多个服务中心注册用逗号隔开</span></span><br><span class="line"><span class="comment">#2.配置自己不注册到服务中eureka:  client:    register-with-eureka: false</span></span><br><span class="line"><span class="comment"># 是否将自己注册到 Eureka Server    fetch-registry: false # 是否从 Eureka Server 获取注册信息</span></span><br></pre></td></tr></table></figure>

<p>配置完之后重启服务，报错消失了！</p>
<p>由于还没有服务注册，所以没有被发现的服务：</p>
<p><img src="../../../../images/2019_10_25_01/SpringCloud-index-Page-1584847519139.jpg" alt="SpringCloud-index-Page"></p>
<h5 id="eureka-client-–注册服务客户端"><a href="#eureka-client-–注册服务客户端" class="headerlink" title="eureka client –注册服务客户端"></a>eureka client –注册服务客户端</h5><p>创建完注册中心后，创建服务客户端</p>
<p>新建一个 maven 项目，在 pom.xml 添加 Eureka Client 依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.9.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">    &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;client&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">        &lt;spring-cloud.version&gt;Greenwich.SR3&lt;/spring-cloud.version&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">        	&lt;dependency&gt;</span><br><span class="line">        		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        		&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">        	&lt;/dependency&gt;</span><br><span class="line">        	&lt;dependency&gt;</span><br><span class="line">        		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        	&lt;/dependency&gt;</span><br><span class="line">        	&lt;dependency&gt;</span><br><span class="line">        		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        		&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        	&lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">        &lt;dependencyManagement&gt;</span><br><span class="line">        	&lt;dependencies&gt;</span><br><span class="line">        		&lt;dependency&gt;</span><br><span class="line">        			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">        			&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">        			&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        			&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        		&lt;/dependency&gt;</span><br><span class="line">        	&lt;/dependencies&gt;</span><br><span class="line">        &lt;/dependencyManagement&gt;</span><br><span class="line">        &lt;build&gt;</span><br><span class="line">        	&lt;plugins&gt;</span><br><span class="line">        		&lt;plugin&gt;</span><br><span class="line">        			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        			&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        		&lt;/plugin&gt;</span><br><span class="line">        	&lt;/plugins&gt;</span><br><span class="line">        &lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>同样的要先创建一个启动类 ClientApplication</p>
<p>启动前也要在 ClientApplication 启动类上添加注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//添加注解才能真正的启动Eureka Client.@EnableDiscoveryClient</span></span><br><span class="line"><span class="comment">//是 spring-cloud-commons 项目的注解，是一个高度的抽象，对各种服务发现组件都提供了支持，如 Zookeeper 和 Consul 也支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ClientApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>客户端不同注册中心能之间启动，需要先配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">7761</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">client-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>先启动好 Eureka Server，再启动 Eureka Client</p>
<p>都启动之后，在你的注册中心有你的 client 注册进去，则 Eureka Client 算初步完成创建</p>
<p><img src="../../../../images/2019_10_25_01/SpringCloud-Client-1584847530213.jpg" alt="SpringCloud-Client"></p>
<h2 id="Eureka-总结："><a href="#Eureka-总结：" class="headerlink" title="Eureka 总结："></a>Eureka 总结：</h2><ul>
<li>@EnableEurekaServer @EnableEurekaClient</li>
<li>心跳检查、健康检查、负载均衡等功能</li>
<li>Eureka 的高可用，生成上建议至少两台以上</li>
<li><strong>分布式系统中，服务注册中心是最重要的基础部分</strong></li>
</ul>
<hr>
<h2 id="鸣谢："><a href="#鸣谢：" class="headerlink" title="鸣谢："></a>鸣谢：</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/4c0PQO-u9qfP-sTFHUdVkA" target="_blank" rel="noopener">Spring Cloud 构建微服务架构（一）服务注册与发现、高可用（Eureka）</a>—–程序员手册大全</li>
<li><a href="http://blog.didispace.com/springcloud1/" target="_blank" rel="noopener">Spring Cloud 构建微服务架构（一）服务注册与发现</a>——翟永超</li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud学习笔记二：总架构概略</title>
    <url>/2019/10/24/the-learning-notes-by-SpringCloud-framework-overview/</url>
    <content><![CDATA[<p>这篇博客主要讲 SpringCloud 架构，不会细讲，总的介绍一下 SpringCloud 整体架构</p>
<a id="more"></a>

<p><img src="../../../../images/2019_10_24_01/springCloud-total-framework-1584847070140.jpg" alt="springCloud-total-framework"></p>
<h2 id="对-SpringCloud-技术名称的理解"><a href="#对-SpringCloud-技术名称的理解" class="headerlink" title="对 SpringCloud 技术名称的理解"></a>对 SpringCloud 技术名称的理解</h2><p>1、Sleuth-链路跟踪 为服务之间调用提供链路追踪。通过 Sleuth 可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长。从而让我们可以很方便的理清各微服务间的调用关系。</p>
<p>2、断路器（Hystrix）在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在 Spring Cloud 可以用 RestTemplate+Ribbon 和 Feign 来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证 100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet 容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。Netflix 开源了 Hystrix 组件，实现了断路器模式，SpringCloud 对这一组件进行了整合</p>
<p>3、Turbine 集群监控 Turbine 是聚合服务器发送事件流数据的一个工具，用来监控集群下 hystrix 的 metrics 情况。 通过 turbine 可以监控集群的请求量，可以知道系统的请求高峰期，从而更好的知道系统的短板在哪里。</p>
<p>4、Consul 服务治理 和 Eureka 服务治理 由于 Spring Cloud 为服务治理做了一层抽象接口，所以在 Spring Cloud 应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper。</p>
<p>Spring Cloud Consul 项目是针对 Consul 的服务治理实现。Consul 是一个分布式高可用的系统，它包含多个组件，但是作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。它包含了下面几个特性：服务发现、 健康检查、 Key/Value 存储、 多数据中心。由于 Consul 自身提供了服务端，所以我们不需要像之前实现 Eureka 的时候创建服务注册中心，直接通过下载 consul 的服务端程序就可以使用。Consul 比 Eureka 注册支持的更多一些。</p>
<p>5、config 配置管理 引入 spring cloud config 后，我们的外部配置文件就可以集中放置在一个 git 仓库里，再新建一个 config server，用来管理所有的配置文件，维护的时候需要更改配置时，只需要在本地更改后，推送到远程仓库，所有的服务实例都可以通过 config server 来获取配置文件，这时每个服务实例就相当于配置服务的客户端 config client,为了保证系统的稳定，配置服务端 config server 可以进行集群部署</p>
<p>6、Nginx 用来做反向代理、负载均衡，当有请求的时候，根据配置的调度策略（加权轮询、IP 哈希、最少连接数、一致性哈希）给请求者返回相应的服务器 IP。</p>
<p>7、Zuul 服务网关 zuul 的核心是一系列的 filters, 其作用可以类比 Servlet 框架的 Filter Zuul 的主要功能是路由和过滤器。是各种服务的统一入口，同时还会用来提供监控、授权、安全、调度等等；可以通过扩展 ZuulFilter，在执行方法之前，做各种检查工作。</p>
<h2 id="SpringCloud-项目"><a href="#SpringCloud-项目" class="headerlink" title="SpringCloud 项目"></a>SpringCloud 项目</h2><h3 id="SpringCloud-的简单介绍"><a href="#SpringCloud-的简单介绍" class="headerlink" title="SpringCloud 的简单介绍"></a>SpringCloud 的简单介绍</h3><p>springCloud 是基于 SpringBoot 的一整套实现微服务的框架。他提供了微服务开发所需的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等组件。最重要的是，跟 spring boot 框架一起使用的话，会让你开发微服务架构的云服务非常好的方便。</p>
<p>SpringBoot 旨在简化创建产品级的 Spring 应用和服务，简化了配置文件，使用嵌入式 web 服务器，含有诸多开箱即用微服务功能</p>
<p>spring cloud 子项目包括：</p>
<p>Spring Cloud Config：配置管理开发工具包，可以让你把配置放到远程服务器，目前支持本地存储、Git 以及 Subversion。</p>
<p>Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。</p>
<p>Spring Cloud Netflix：针对多种 Netflix 组件提供的开发工具包，其中包括 Eureka、Hystrix、Zuul、Archaius 等。</p>
<p>Netflix Eureka：云端负载均衡，一个基于 REST 的服务，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移。</p>
<p>Netflix Hystrix：容错管理工具，旨在通过控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</p>
<p>Netflix Zuul：边缘服务工具，是提供动态路由，监控，弹性，安全等的边缘服务。</p>
<p>Netflix Archaius：配置管理 API，包含一系列配置管理 API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</p>
<p>Spring Cloud for Cloud Foundry：通过 Oauth2 协议绑定服务到 CloudFoundry，CloudFoundry 是 VMware 推出的开源 PaaS 云平台。</p>
<p>Spring Cloud Sleuth：日志收集工具包，封装了 Dapper,Zipkin 和 HTrace 操作。</p>
<p>Spring Cloud Data Flow：大数据操作工具，通过命令行方式操作数据流。</p>
<p>Spring Cloud Security：安全工具包，为你的应用程序添加安全控制，主要是指 OAuth2。</p>
<p>Spring Cloud Consul：封装了 Consul 操作，consul 是一个服务发现与配置工具，与 Docker 容器可以无缝集成。</p>
<p>Spring Cloud Zookeeper：操作 Zookeeper 的工具包，用于使用 zookeeper 方式的服务注册和发现。</p>
<p>Spring Cloud Stream：数据流操作开发包，封装了与 Redis,Rabbit、Kafka 等发送接收消息。</p>
<p>Spring Cloud CLI：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件</p>
<h3 id="springCloud-的特点"><a href="#springCloud-的特点" class="headerlink" title="springCloud 的特点"></a>springCloud 的特点</h3><ol>
<li>约定优于配置</li>
<li>开箱即用、快速的启动</li>
<li>适用各种环境</li>
<li>轻量级的组件</li>
<li>组件丰富，功能完整</li>
</ol>
<h3 id="SpringCluod-逻辑结构图"><a href="#SpringCluod-逻辑结构图" class="headerlink" title="SpringCluod 逻辑结构图"></a>SpringCluod 逻辑结构图</h3><p><img src="../../../../images/2019_10_24_01/springcloud-role-1584847082466.jpg" alt="springcloud-role"></p>
<p>Spring cloud 作为当下主流的微服务框架，让我们实现微服务架构简单快捷，Spring cloud 中各个组件在微服务架构中扮演的角色如上图所示，黑线表示注释说明，蓝线由 A 指向 B，表示 B 从 A 处获取服务。包括各种微服务、注册发现、服务网关、熔断器、统一配置、跟踪服务等……</p>
<h2 id="SpringCloud-组件角色概况"><a href="#SpringCloud-组件角色概况" class="headerlink" title="SpringCloud 组件角色概况"></a>SpringCloud 组件角色概况</h2><h3 id="feign（接口调用）"><a href="#feign（接口调用）" class="headerlink" title="feign（接口调用）"></a>feign（接口调用）</h3><p>微服务之间通过 Rest 接口通讯，Spring Cloud 提供 Feign 框架来支持 Rest 的调用，Feign 使得不同进程的 Rest 接口调用得以用优雅的方式进行，这种优雅表现得就像同一个进程调用一样。。</p>
<h3 id="Netflix-eureka（注册发现）"><a href="#Netflix-eureka（注册发现）" class="headerlink" title="Netflix eureka（注册发现）"></a>Netflix eureka（注册发现）</h3><p>微服务模式下，一个大的 Web 应用通常都被拆分为很多比较小的 web 应用(服务)，这个时候就需要有一个地方保存这些服务的相关信息，才能让各个小的应用彼此知道对方，这个时候就需要在注册中心进行注册。每个应用启动时向配置的注册中心注册自己的信息（ip 地址，端口号, 服务名称等信息），注册中心将他们保存起来，服务间相互调用的时候，通过服务名称就可以到注册中心找到对应的服务信息，从而进行通讯。注册与发现服务为微服务之间的调用带来了方便，解决了硬编码的问题。服务间只通过对方的服务 id，而无需知道其 ip 和端口即可以获取对方方服务。</p>
<h3 id="Ribbon（负载均衡）"><a href="#Ribbon（负载均衡）" class="headerlink" title="Ribbon（负载均衡）"></a>Ribbon（负载均衡）</h3><p>Ribbon 是 Netflix 发布的负载均衡器，它有助于控制 HTTP 和 TCP 客户端的行为。为 Ribbon，配置服务提供者的地址列表后，Ribbon 就可基于某种负载均衡算法，自动地帮助服务消费者去请求。Ribbon 默认为我们提供了很多的负载均衡算法，例如轮询、随机等。当然，我们也可为 Ribbon 实现自定义的负载均衡算法。在 SpringCloud 中，当 Ribbon 与 Eureka 配合使用时，Ribbon 可自动从 EurekaServer 获取服务提供者的地址列表，并基于负载均衡算法，请求其中一个服务提供者的实例（为了服务的可靠性，一个微服务可能部署多个实例）。</p>
<h3 id="Hystrix（熔断器）"><a href="#Hystrix（熔断器）" class="headerlink" title="Hystrix（熔断器）"></a>Hystrix（熔断器）</h3><p>当服务提供者响应非常缓慢，那么消费者对提供者的请求就会被强制等待，直到提供者响应或超时。在高负载场景下，如果不做任何处理，此类问题可能会导致服务消费者的资源耗竭甚至整个系统的崩溃（雪崩效应）。Hystrix 正是为了防止此类问题发生。Hystrix 是由 Netflix 开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性。Hystrix 主要通过以下几点实现延迟和容错。</p>
<p>包裹请求：使用 HystrixCommand（或 HystrixObservableCommand）包裹对依赖的调用逻辑，每个命令在独立线程中执行。这使用了设计模式中的“命令模式”。</p>
<p>跳闸机制：当某服务的错误率超过一定阈值时，Hystrix 可以自动或者手动跳闸，停止请求该服务一段时间。</p>
<p>资源隔离：Hystrix 为每个依赖都维护了一个小型的线程池（或者信号量）。如果该线程池已满，发往该依赖的请求就被立即拒绝，而不是排队等候，从而加速失败判定。</p>
<p>监控：Hystrix 可以近乎实时地监控运行指标和配置的变化，例如成功、失败、超时和被拒绝的请求等。</p>
<p>回退机制：当请求失败、超时、被拒绝，或当断路器打开时，执行回退逻辑。回退逻辑可由开发人员指定。</p>
<h3 id="Zuul（网关）"><a href="#Zuul（网关）" class="headerlink" title="Zuul（网关）"></a>Zuul（网关）</h3><p>不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求。例如一个电影购票的手机 APP，可能调用多个微服务的接口才能完成一次购票的业务流程，如果让客户端直接与各个微服务通信，会有以下的问题：</p>
<p>客户端会多次请求不同的微服务，增加了客户端的复杂性。</p>
<p>存在跨域请求，在一定场景下处理相对复杂。</p>
<p>认证复杂，每个服务都需要独立认证。</p>
<p>难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将很难实施。</p>
<p>某些微服务可能使用了对防火墙/浏览器不友好的协议，直接访问时会有一定的困难。</p>
<p>以上问题可借助微服务网关解决。微服务网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过微服务网关。使用微服务网关后，微服务网关将封装应用程序的内部结构，客户端只用跟网关交互，而无须直接调用特定微服务的接口。这样，开发就可以得到简化。不仅如此，使用微服务网关还有以下优点：</p>
<p>易于监控。可在微服务网关收集监控数据并将其推送到外部系统进行分析。</p>
<p>易于认证。可在微服务网关上进行认证，然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。</p>
<p>减少了客户端与各个微服务之间的交互次数。</p>
<h3 id="SpringCloudBus（统一配置服务）"><a href="#SpringCloudBus（统一配置服务）" class="headerlink" title="SpringCloudBus（统一配置服务）"></a>SpringCloudBus（统一配置服务）</h3><p>对于传统的单体应用，常使用配置文件管理所有配置。例如一个 SpringBoot 开发的单体应用，可将配置内容放在 application.yml 文件中。如果需要切换环境，可设置多个 Profile，并在启动应用时指定 spring.profiles.active={profile}。然而，在微服务架构中，微服务的配置管理一般有以下需求：</p>
<p>集中管理配置。一个使用微服务架构的应用系统可能会包含成百上千个微服务，因此集中管理配置是非常有必要的。</p>
<p>不同环境，不同配置。例如，数据源配置在不同的环境（开发、测试、预发布、生产等）中是不同的。</p>
<p>运行期间可动态调整。例如，可根据各个微服务的负载情况，动态调整数据源连接池大小或熔断阈值，并且在调整配置时不停止微服务。</p>
<p>配置修改后可自动更新。如配置内容发生变化，微服务能够自动更新配置。综上所述，对于微服务架构而言，一个通用的配置管理机制是必不可少的，常见做法是使用配置服务器管理配置。Spring cloud bus 利用 Git 或 SVN 等管理配置、采用 Kafka 或者 RabbitMQ 等消息总线通知所有应用，从而实现配置的自动更新并且刷新所有微服务实例的配置。</p>
<h3 id="SpringCloud-Sleuth-ZipKin（跟踪服务）"><a href="#SpringCloud-Sleuth-ZipKin（跟踪服务）" class="headerlink" title="SpringCloud Sleuth + ZipKin（跟踪服务）"></a>SpringCloud Sleuth + ZipKin（跟踪服务）</h3><p>Sleuth 和 Zipkin 结合使用可以通过图形化的界面查看微服务请求的延迟情况以及各个微服务的依赖情况。需要注意的是 Spring boot2 及以上不在支持 Zipkin 的自定义，需要到官方网站下载 ZipKin 相关的 jar 包。</p>
<h3 id="SpringCloud-Actuator（执行器）"><a href="#SpringCloud-Actuator（执行器）" class="headerlink" title="SpringCloud Actuator（执行器）"></a>SpringCloud Actuator（执行器）</h3><p>提供了很多监控端点如/actuator/info、/actuator/health、/acutator/refresh 等，可以查看微服务的信息、健康状况、刷新配置等。</p>
<hr>
<h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>本博客参考自：<a href="https://mp.weixin.qq.com/s/qjLUfuXUQWfczMuFsIRlcQ" target="_blank" rel="noopener">简单了解 SpringCloud 的微服务架构</a> –程序员手册大全</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud学习笔记一：前言</title>
    <url>/2019/10/23/the-learning-notes-by-SpringCloud-preface/</url>
    <content><![CDATA[<p>最近在公司写文档，可以抽出时间来充实一下自己，我打算认认真真的学一遍 springCloud，然后将我会尽可能详细的将自己学习的过程记录下来……</p>
<p>好了，废话不多说，SpringCloud 走起！……</p>
<a id="more"></a>

<p>SpringCloud 官网：<a href="https://spring.io/" target="_blank" rel="noopener">Spring.io</a>以及<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener">SpringCloud 介绍</a></p>
<p>SpringCloud 中文：<a href="https://www.springcloud.cc/" target="_blank" rel="noopener">中文文档</a></p>
<h2 id="二：SpringCloud-的学习目录"><a href="#二：SpringCloud-的学习目录" class="headerlink" title="二：SpringCloud 的学习目录"></a>二：SpringCloud 的学习目录</h2><p>这个是我自己的学习路线，我会将我最近学习成果一一记录，主要是能巩固自己对 SpringCloud 的理解与运行</p>
<ul>
<li><p>SpringCloud 的总架构介绍</p>
</li>
<li><p>SpringCloud 的服务注册与发现</p>
</li>
<li><p>SpringCloud 的消费实现</p>
</li>
<li><p>SpringCloud 的断路器实现</p>
<p>这个目录会不断更新……</p>
</li>
</ul>
<h2 id="三：为什么我要学习微服务？"><a href="#三：为什么我要学习微服务？" class="headerlink" title="三：为什么我要学习微服务？"></a>三：为什么我要学习微服务？</h2><p>这也是我在学习之前问自己的一个问题，我为什么要学微服务，学 springcloud……我真的用的上吗？……</p>
<h4 id="1-为什么要学微服务"><a href="#1-为什么要学微服务" class="headerlink" title="1.为什么要学微服务"></a>1.为什么要学微服务</h4><p>我个人的话，想分几点回答吧！</p>
<p>① 微服务是趋势，现在很多公司都想要引入微服务的实现技术</p>
<p>② 微服务对比单体架构的优点非常明显，在下面我会用问答的方式回答他们的对比</p>
<p>③ 学习微服务能提升自己的技术实力，在搭建的 SpringCloud 过程中能学一下搭建所用的方法和里面包含的技术</p>
<p>④ 好吧，这个才是重头戏！最近在公司写文档，太无聊了，觉得需要些新东西来刺激一下自己</p>
<h4 id="2-学-springcloud-我用的上吗？"><a href="#2-学-springcloud-我用的上吗？" class="headerlink" title="2.学 springcloud 我用的上吗？"></a>2.学 springcloud 我用的上吗？</h4><p>① 这个其实就我这个今年毕业的小菜鸟来说，好像是用不上的，但是作为技术储备，我觉得还是可以好好学习和研究一下的</p>
<p>② 学习 springcloud 的同时，我可以在学习的过程中了解微服务的思想，这对于未来的我来说是一个好的东西。</p>
<p>希望在学习之前先问自己这些问题，这样能在学习过程不会觉得很乏味，并且充满冲劲！</p>
<h2 id="四：微服务是什么？"><a href="#四：微服务是什么？" class="headerlink" title="四：微服务是什么？"></a>四：微服务是什么？</h2><p>好吧，和别的博主一样，在学习一个技术之前，先了解一下这个技术的相关理论知识（为了面试的时候能更好的吹 X，能提高自己的谈薪资格……O(∩_∩)O）</p>
<h3 id="1：微服务是什么呢？"><a href="#1：微服务是什么呢？" class="headerlink" title="1：微服务是什么呢？"></a>1：微服务是什么呢？</h3><p>我觉得微服务是一种架构风格，模块化系统。</p>
<blockquote>
<p>Martin Fowler 对微服务的描述：<br>​ <em>微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行再自己的进程种，服务间通信采用轻量及通信机制（通常用 HTTP 资源 API）。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务公用一个最小型的集中式管理，服务可用不同的语言开发，使用不同的数据存储技术。</em></p>
</blockquote>
<p>又臭又长是吧，总结就一句话：</p>
<p>将单一的文件项目划分为一组小的服务（模块），每个服务运行在其独立的自己的进程中</p>
<h3 id="2：微服务架构是什么？"><a href="#2：微服务架构是什么？" class="headerlink" title="2：微服务架构是什么？"></a>2：微服务架构是什么？</h3><p>一种架构模式，提倡多个小的服务之间相互协调配合，低耦合开发</p>
<p>特征：</p>
<ul>
<li>每个微服务可独立运行在自己的进程里</li>
<li>一系列独立运行的微服务共同构建器整个系统</li>
<li>每个服务为独立的业务开发，一个微服务只关注某个特定的功能</li>
<li>微服务之间通过一些轻量的通信机制进行通信，比如：同故宫 RestFulApi 进行调用</li>
<li>可以使用不同的语言与数据存储技术</li>
<li>全自动的部署机制</li>
</ul>
<h3 id="3：微服务的优点是什么？"><a href="#3：微服务的优点是什么？" class="headerlink" title="3：微服务的优点是什么？"></a>3：微服务的优点是什么？</h3><p>在说微服务的优点之前，先说说单体架构的优缺点</p>
<h4 id="单体架构："><a href="#单体架构：" class="headerlink" title="单体架构："></a>单体架构：</h4><p>优点：</p>
<ul>
<li><p>容易测试</p>
</li>
<li><p>容易部署</p>
<p>缺点：</p>
</li>
<li><p>开发效率低</p>
</li>
<li><p>代码维护难</p>
</li>
<li><p>部署不灵活</p>
</li>
<li><p>稳定性不高</p>
</li>
<li><p>扩展性不好</p>
</li>
</ul>
<p>说完单体架构的优缺点，在来看看微服务的优缺点</p>
<h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><ul>
<li><p>优点：</p>
</li>
<li><p>每个服务足够内聚，足够小，容易理解聚焦一个指定的业务功能和业务需求</p>
</li>
<li><p>开发简单，开发效率提高，一个服务只干一件事</p>
</li>
<li><p>微服务能够被小团队独立开发</p>
</li>
<li><p>微服务是松耦合的，有功能意义的服务，开发和部署都是独立的</p>
</li>
<li><p>微服务能使用不同的语言开发</p>
</li>
<li><p>易于被开发人员理解，修改和维护</p>
</li>
<li><p>允许利用融合最新的技术</p>
</li>
<li><p>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库</p>
</li>
<li><p>……</p>
<p>缺点：</p>
</li>
<li><p>开发人员要处理分布式系统的复杂性</p>
</li>
<li><p>多服务运维难度，随着服务的增加，运维的压力也越大</p>
</li>
<li><p>系统部署依赖</p>
</li>
<li><p>服务间的通信成本</p>
</li>
<li><p>数据一致性</p>
</li>
<li><p>性能监控</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>就先写这么多了。之后我会在后面附上相关的面试题，不断积累吧！</p>
<h2 id="五：微服务的面试题"><a href="#五：微服务的面试题" class="headerlink" title="五：微服务的面试题"></a>五：微服务的面试题</h2><h5 id="1-什么是微服务？"><a href="#1-什么是微服务？" class="headerlink" title="1.什么是微服务？"></a>1.什么是微服务？</h5><p>微服务英文名称 Microservice，Microservice 架构模式就是将整个 Web 应用组织为一系列小的 Web 服务。这些小的 Web 服务可以独立地编译及部署，并通过各自暴露的 API 接口相互通讯。它们彼此相互协作，作为一个整体为用户提供功能，却可以独立地进行扩。</p>
<p>微服务架构需要的功能或使用场景</p>
<p>1：我们把整个系统根据业务拆分成几个子系统。</p>
<p>2：每个子系统可以部署多个应用，多个应用之间使用负载均衡。</p>
<p>3：需要一个服务注册中心，所有的服务都在注册中心注册，负载均衡也是通过在注册中心注册的服务来使用一定策略来实现。</p>
<p>4：所有的客户端都通过同一个网关地址访问后台的服务，通过路由配置，网关来判断一个 URL 请求由哪个服务处理。请求转发到服务上的时候也使用负载均衡。</p>
<p>5：服务之间有时候也需要相互访问。例如有一个用户模块，其他服务在处理一些业务的时候，要获取用户服务的用户数据。</p>
<p>6：需要一个断路器，及时处理服务调用时的超时和错误，防止由于其中一个服务的问题而导致整体系统的瘫痪。</p>
<p>7：还需要一个监控功能，监控每个服务调用花费的时间等。</p>
<p>目前主流的微服务框架：Dubbo、 SpringCloud、thrift、Hessian 等，目前国内的中小企业用的大多数都是 Dubbo，SpringCloud。</p>
<h5 id="2-微服务架构是什么？"><a href="#2-微服务架构是什么？" class="headerlink" title="2.微服务架构是什么？"></a>2.微服务架构是什么？</h5><p>答案在上面有回答！</p>
<h5 id="3-微服务的优缺点分别是什么？说下在项目开发中碰到的坑……"><a href="#3-微服务的优缺点分别是什么？说下在项目开发中碰到的坑……" class="headerlink" title="3.微服务的优缺点分别是什么？说下在项目开发中碰到的坑……"></a>3.微服务的优缺点分别是什么？说下在项目开发中碰到的坑……</h5><p>答案在上面有回答！</p>
<h5 id="4-你所知道的微服务技术栈有哪些，列举……"><a href="#4-你所知道的微服务技术栈有哪些，列举……" class="headerlink" title="4.你所知道的微服务技术栈有哪些，列举……"></a>4.你所知道的微服务技术栈有哪些，列举……</h5><p><img src="../../../../images/2019_10_23_01/Microservice-technology-stack-1584796272503.jpg" alt="Microservice-technology-stack"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>又长大了</title>
    <url>/2019/10/22/grow-up-again-by-23/</url>
    <content><![CDATA[<p> 恍恍惚惚！我又长大了一岁！……</p>
<a id="more"></a>

<p> 毋庸置疑！年龄的增长身上的责任也更重啦，身边也出现了需要呵护的人！</p>
<p> 不同的是，今年是自己工作的第一个生日！感觉也没什么可以送给自的……</p>
<p> 或许这个博客就是给自己的最好的礼物吧！</p>
<p> 希望在之后的生活，博客能和我一块成长！</p>
<p> 记录一路来的学习过程，记录一路来的生活片段……</p>
<p> 好吧！这是一个技术博客，我还是好好学习技术吧！分享更多的技术知识给大家……</p>
<p> 那就加油啦！</p>
<hr>
<p>勿忘初心，砥砺前行。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>更改Hexo主题</title>
    <url>/2019/10/19/change-the-theme-of-Hexo/</url>
    <content><![CDATA[<h3 id="一：下载主题"><a href="#一：下载主题" class="headerlink" title="一：下载主题"></a>一：下载主题</h3><p> 1：git bash进入你的博客文件夹中</p>
<p> 2：将你喜欢的主题下载（我选择的是NexT）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>

<p> 3：主题下载完成后，打开你的博客文件夹目录，在./themes下会多一个next的文件夹</p>
<a id="more"></a>

<h3 id="二：主题更改"><a href="#二：主题更改" class="headerlink" title="二：主题更改"></a>二：主题更改</h3><p> 1：使用开发工具（我用WebStorm）打开你博客文件夹目录下的“_config.yml”配置文件</p>
<p> 2：Ctr+F直接搜索“theme”，修改为你的新主题</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions#</span></span><br><span class="line"><span class="comment"># Plugins: https://hexo.io/plugins/#</span></span><br><span class="line"><span class="comment"># Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p> 3：主题修改后可先本地调试查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo s</span></span><br></pre></td></tr></table></figure>

<h3 id="三：发布"><a href="#三：发布" class="headerlink" title="三：发布"></a>三：发布</h3><p> 1：发布你的新主题到github</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo d -g <span class="comment">#deploy发布 generate生成</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果缓存出问题，可先执行清除缓存命令，再发布</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></span><br></pre></td></tr></table></figure>

<h3 id="四：完成"><a href="#四：完成" class="headerlink" title="四：完成"></a>四：完成</h3><p> 完成所有步骤你会发现你的博客已经是新的主题啦！</p>
<p> NexT更多的使用和配置点<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">这里</a>！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>记录创建Github-blog过程</title>
    <url>/2019/10/16/the-process-of-record-create-github-blog/</url>
    <content><![CDATA[<p>现在我来记录一下我创建这个博客的过程……</p>
<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>使用<a href="https://github.com/" target="_blank" rel="noopener">github</a>来搭建个人博客</p>
<p>当然要先简单了解<a href="https://pages.github.com/" target="_blank" rel="noopener">github page</a></p>
<p>虽然官方推荐使用 Jekyll+github 的方式来创建网页，但我选择使用 Hexo+github 来搭建自己的博客网站，现在来记录一下我的搭建过程！</p>
<a id="more"></a>

<h3 id="1：环境搭建—nodejs，git"><a href="#1：环境搭建—nodejs，git" class="headerlink" title="1：环境搭建—nodejs，git"></a>1：环境搭建—nodejs，git</h3><p>首先得进行环境搭建</p>
<p>①<a href="http://nodejs.cn/" target="_blank" rel="noopener">nodejs</a>安装：nodejs 就是搭建博客前端的基础</p>
<p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">安装流程</a></p>
<p>②<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>安装：git 是搭建博客与 github 的连接</p>
<p><a href="https://www.runoob.com/git/git-install-setup.html" target="_blank" rel="noopener">安装流程</a></p>
<p>最后介绍我搭建的电脑环境：</p>
<ul>
<li>Win10</li>
<li><a href="mailto:node@v10.16.0">node@v10.16.0</a></li>
<li><a href="mailto:npm@6.9.0">npm@6.9.0</a></li>
<li><a href="mailto:git@2.23.0">git@2.23.0</a></li>
</ul>
<h3 id="2：准备-github-账号"><a href="#2：准备-github-账号" class="headerlink" title="2：准备 github 账号"></a>2：准备 github 账号</h3><p>① 没有 github 账号：进入<a href="https://github.com/" target="_blank" rel="noopener">github</a>官网进行<a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">注册</a>（<a href="https://jingyan.baidu.com/article/86fae346e723303c49121abb.html" target="_blank" rel="noopener">教程</a>）</p>
<p>② 有 github 账号：直接登录进入你的<a href="https://github.com/" target="_blank" rel="noopener">github</a></p>
<h2 id="三：搭建-github-博客"><a href="#三：搭建-github-博客" class="headerlink" title="三：搭建 github 博客"></a>三：搭建 github 博客</h2><h3 id="1：在-Github-创建仓库"><a href="#1：在-Github-创建仓库" class="headerlink" title="1：在 Github 创建仓库"></a>1：在 Github 创建仓库</h3><p>登录进你的 github</p>
<p>首页右上角头像那里有一个“+”号，点击后选择“New repositor”。</p>
<p><img src="../../../../images/2019_10_16_01/new_repositor_no_1.png" alt="new_repositor_no_1"></p>
<p>进入到仓库创建页面</p>
<p><img src="../../../../images/2019_10_16_01/create_repositor_no_1.png" alt="create_repositor_no_1"></p>
<p>创建完之后点击“Settings”</p>
<p><img src="../../../../images/2019_10_16_01/click_settings_no_1.png" alt="click_settings_no_1"></p>
<p>往下拉找到 GitHub Pages，查看你的博客地址，仓库创建完成！</p>
<p><img src="../../../../images/2019_10_16_01/find_github_pages_no_1.png" alt="find_github_pages_no_1"></p>
<h3 id="2：搭建-Hexo"><a href="#2：搭建-Hexo" class="headerlink" title="2：搭建 Hexo"></a>2：搭建 Hexo</h3><p>目前支持 Markdown 的博客工具中，我知道的比较火的有 Jekyll 和 Hexo。</p>
<p>Jekyll 流行是因为官方推荐使用，配合 Github 开发可定制程度非常高。</p>
<p>Hexo 则胜在依赖较少只需要安装 node 就够了（没错，是我太懒，另一个原因是我的伙伴也都用 hexo）。</p>
<p>那就敲定了我的博客是 hexo+github 来搭建！</p>
<h4 id="1：安装Hexo"><a href="#1：安装Hexo" class="headerlink" title="1：安装Hexo"></a>1：安装<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></h4><p>先找好一个你要创建 hexo 文件的地方，例如：</p>
<p><img src="../../../../images/2019_10_16_01/1571379168338.png" alt="1571379168338"></p>
<p><em>（好吧！我就直接在我的 D 盘新建了一个 hexo 的文件夹就将 Hexo 安装进去了）</em></p>
<p>在安装好 node 之后可以打开 cmd（命令行操作），先进入到你新建的文件夹中，再执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-cli -g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo s</span></span><br></pre></td></tr></table></figure>

<p>这些操作完了之后，可以看到 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a>，点击进去就可以查看了。关于 Hexo 的语法点击<a href="https://hexo.io/docs/commands.html" target="_blank" rel="noopener">这里</a>。</p>
<h4 id="2：配置-SSH-Key"><a href="#2：配置-SSH-Key" class="headerlink" title="2：配置 SSH Key"></a>2：配置 SSH Key</h4><p>使用 SSH Key 解决本地和服务器连接。</p>
<h5 id="①-本地生成-key"><a href="#①-本地生成-key" class="headerlink" title="① 本地生成 key"></a>① 本地生成 key</h5><p>首先进入 cmd，输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/.ssh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">检查本机是否已经存指ssh密钥</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果提示<span class="string">"No such file or directory"</span>则说明本机原来没有生成过ssh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果进去了则可以跳过下面的生成key命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"你的Github登录账号(登录邮箱)"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">生成新的key文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">完成后则生成ssh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/id_rsa.pub <span class="comment">#获取你生成的key</span></span></span><br></pre></td></tr></table></figure>

<p><img src="../../../../images/2019_10_16_01/get_cat_ssh_key_no_1.png" alt="get_cat_ssh_key_no_1"></p>
<p>② 将生成的 key 配置到 github</p>
<p>先点击你 github 首页右上角的头像，然后往下找到 settings</p>
<p><img src="../../../../images/2019_10_16_01/click_github_settings_no_1.png" alt="click_github_settings_no_1"></p>
<p>点击进入到你的配置页面，找到并打开 SSH and GPS keys，然后点击右边的 new SSH Key</p>
<p><img src="../../../../images/2019_10_16_01/ssh_key_settings_no_1.png" alt="ssh_key_settings_no_1"></p>
<p>然后添加你在上面生成的 key，从 ssh-rsa……整段复制过来，然后就完成了 key 配置了！</p>
<p><img src="../../../../images/2019_10_16_01/add_ssh_key_no_1.png" alt="add_ssh_key_no_1"></p>
<p>最后再测试一下 key 是否关联成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash">当出现Are you sure you want to <span class="built_in">continue</span> connecting (yes/no)?</span></span><br><span class="line"><span class="meta">#</span><span class="bash">选择Yes，则出现有successfully的一段话就说明SSH Key配置成功！</span></span><br></pre></td></tr></table></figure>

<h4 id="3：配置-Hexo-和-git-的连接"><a href="#3：配置-Hexo-和-git-的连接" class="headerlink" title="3：配置 Hexo 和 git 的连接"></a>3：配置 Hexo 和 git 的连接</h4><p>打开你创建的 hexo 文件夹，找到里面的_config.yml 文件，使用开发工具打开（我使用的是 InteliJ 的 WebStorm）,配置以下代码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repository:</span> <span class="string">https://github.com/你的GitHub名称/你的项目库名称.github.io.git</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>然后再刷新提交你的 Hexo 代码，再 git Bash 里输入以下代码，不报错则说明你的个人博客已经搭建好了！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo g <span class="comment">#生成</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo d <span class="comment">#代码提交</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 想先本地演示的话可以先 hexo s</span></span><br></pre></td></tr></table></figure>

<h2 id="四：博客完成"><a href="#四：博客完成" class="headerlink" title="四：博客完成"></a>四：博客完成</h2><p>到这里说明你的博客已经搭建完成了！最后来看看我们的成果吧！</p>
<h3 id="1：完成效果"><a href="#1：完成效果" class="headerlink" title="1：完成效果"></a>1：完成效果</h3><p>第一次出现的效果一般都为这样啦</p>
<p><img src="../../../../images/2019_10_16_01/first_open_blog_by_hexo_no_1.png" alt="first_open_blog_by_hexo_no_1"></p>
<h3 id="2：博客编写"><a href="#2：博客编写" class="headerlink" title="2：博客编写"></a>2：博客编写</h3><p>现在我们来写一次博客，（我第一次写博客也是迷糊的很……）</p>
<p>① 创建一个<a href="https://hexo.io/docs/writing" target="_blank" rel="noopener">新的文章</a>，创建完之后会在你的文件夹里/source/_post/下生成你创建的 md 文本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new &lt;post&gt;</span></span><br></pre></td></tr></table></figure>

<p>② 使用支持<a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">Markdown</a>文本编辑工具进行文章编辑（我使用的是 Typora，更方便编辑，当然 webStorm 也可以）</p>
<hr>
<h2 id="鸣谢支持"><a href="#鸣谢支持" class="headerlink" title="鸣谢支持"></a>鸣谢支持</h2><p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">小茗同学的博客园</a></p>
<p><a href="https://asdfv1929.github.io/2017/11/18/hexo-next-blog/" target="_blank" rel="noopener">asdfbv1929</a></p>
<p>额(⊙﹏⊙)！第一次写那么长的博客文章，有很多不懂的地方，效率也挺低的（写了两天……,,ԾㅂԾ,,）</p>
<p>但我相信我能不断提高自己的啦！时不时的来更新我的学习生活，gogogo……</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2019/10/16/My-First-Blog/</url>
    <content><![CDATA[<p>第一篇博客先来简单聊两句：</p>
<h3 id="一：写博客的目的"><a href="#一：写博客的目的" class="headerlink" title="一：写博客的目的"></a>一：写博客的目的</h3><p>在创建博客的道路上的我其实是被自愿的！如果能躺在荣华富贵，我也不用如此努力的提升自己。</p>
<p>当然这都是开玩笑的啦！博客的目的其实是想记录一下自己的成长之路。希望未来的自己能看到自己不断向上的过程同时也能将自己遇到的问题或者遇到的好的东西分享给大家！共同进步嘛……</p>
<a id="more"></a>

<h3 id="二：写博客的意义"><a href="#二：写博客的意义" class="headerlink" title="二：写博客的意义"></a>二：写博客的意义</h3><p>记录自己在学习成长的过程！将这个过程分享给大家。</p>
<p>我很懒！希望写博客能让我在学习的事情上坚持下来（为了不让博客空空的……）</p>
<h3 id="三：写博客的内容："><a href="#三：写博客的内容：" class="headerlink" title="三：写博客的内容："></a>三：写博客的内容：</h3><p>作为一个普普通通的小软件开发工程师，我会把我学习的内容记录到博客里，当然我学习的内容也不是只有开发，还会有其他的……</p>
<p>最后呢！感谢大家能看到这个博客的内容！</p>
<hr>
<p>开启我的博客之路啦……</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
